pragma solidity ^0.4.17;

contract oneWinsAll {
 // This is a smart contract for an ethereum-based lottery, in which one single winner is
 // picked based on a random number generated by the hash value of the blocks in ethereum,
 // whenever the number of participants reaches 25. All the currency paid by the participants
 // to join the game will be transferred then to that winner.
 // To participate in the game, one has to pay a certain price.
 // One has also to pick from 1-25 (included) a random integer as his ticket id.

    event purchased(address _user, uint64 _ticketid);
    event awardpaid(address _winner, uint64 _ticketid, uint64 _amount);
    // Events to be watched.
 
    uint64 public price = 5 ether; // A fixed price to join the game.
    uint64 public nlimit = 2; // The max amount of tickets that can be sold out.

    uint64 public sold;     // Records the number of tickets sold.
    mapping(uint64 => address) players;

    constructor(uint64 _price, uint64 _nlimit) public payable {
        sold = 0;
        price = _price;
        nlimit = _nlimit;
    }

    modifier allsold() {
     // Defines a state for the functions below that requires all tickets to be sold.
        require(sold == nlimit);
        _;
    }

    function() public payable {
     // Fallback function.
        revert();
    }

    function join() payable public returns (bool) {
        require(msg.value == price);
        require(sold < nlimit);
        
        // Conditions for the player to join successfully and legally.
        sold += 1;
        players[sold] = msg.sender;
        emit purchased(msg.sender, sold);

        if (sold == nlimit) {
         // The number of participants reaches the upper bound, time to send the award.
            sendrwrd();
        }
        return true;
    }

    function sendrwrd() public allsold payable returns (address) {
        uint64 winnerticket = picker();
        sold = 0;
        // Prevent re-entrancy attack by removing all arguments.
        players[winnerticket].transfer(nlimit * price);
        emit awardpaid(players[winnerticket], winnerticket, nlimit * price);
        return players[winnerticket];
    }

    function picker() public view allsold returns (uint64) {
        bytes memory entropy = abi.encodePacked(block.timestamp, block.number);
        bytes32 hash = sha256(entropy);
        return uint64(hash) % (nlimit-1) + 1;
    }

}